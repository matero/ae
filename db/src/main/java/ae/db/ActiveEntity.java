/*
 * The MIT License
 *
 * Copyright (c) 2018 ActiveEngine.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package ae.db;

import argo.jdom.JsonField;
import com.google.appengine.api.datastore.Entity;
import com.google.appengine.api.datastore.EntityNotFoundException;
import com.google.appengine.api.datastore.Key;
import com.google.appengine.api.datastore.Query;
import com.google.appengine.api.memcache.MemcacheService;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;

/**
 * ActiveRecord over google appengine datastore's {@link Entity}.
 * <p>
 * Usually used as base for code generated by db-processor compiler.
 */
public abstract class ActiveEntity extends ActiveElement implements EntityModel {
        private static final long serialVersionUID = -6755700696013461574L;

        protected ActiveEntity()
        {
                // nothing to do
        }

        /**
         * Initialize an {@link Entity} after its construction.
         *
         * @param data the {@link Entity} to initialize.
         */
        protected void init(final Entity data)
        {
                // nothing to do
        }

        @Override
        public final Key save(final Entity data)
        {
                verify(data);
                try {
                        return saveEntity(data).get();
                } catch (final InterruptedException | ExecutionException e) {
                        throw new PersistenceException("could not save entity", e);
                }
        }

        protected Future<Key> saveEntity(final Entity data)
        {
                final Future<Key> key = asyncDatastore().put(data);
                {
                        final Key dataKey = data.getKey();
                        if (dataKey != null) {
                                memcache().delete(dataKey);
                        }
                }
                return key;
        }

        @Override
        public void delete(final Key key)
        {
                verify(key);
                try {
                        deleteEntity(key).get();
                } catch (final InterruptedException | ExecutionException e) {
                        throw new PersistenceException("could not delete entity", e);
                }
        }

        protected Future<Void> deleteEntity(final Key key)
        {
                Future<Void> deleteDone = asyncDatastore().delete(key);
                memcache().delete(key);
                return deleteDone;
        }

        @Override
        public Entity find(final Key key)
        {
                verify(key);
                try {
                        return getEntity(key);
                } catch (final EntityNotFoundException e) {
                        return null;
                }
        }

        @Override
        public Entity get(final Key key) throws EntityNotFoundException
        {
                verify(key);
                return getEntity(key);
        }

        protected Entity getEntity(final Key key) throws EntityNotFoundException
        {
                final MemcacheService cache = memcache();
                Entity data = (Entity) cache.get(key);
                if (data == null) {
                        data = datastore().get(key);
                        cache.put(key, data);
                }
                return data;
        }

        @Override
        public boolean exists(final Entity data)
        {
                verify(data);
                return checkExists(data.getKey());
        }

        @Override
        public boolean exists(final Key key)
        {
                verify(key);
                return checkExists(key);
        }

        protected boolean checkExists(final Key key)
        {
                final MemcacheService cache = memcache();
                if (!cache.contains(key)) {
                        final Entity data;
                        try {
                                data = datastore().get(key);
                        } catch (final EntityNotFoundException e) {
                                return false;
                        }
                        cache.put(key, data);
                }
                return true;
        }

        protected void verify(final Entity data) throws EntityModel.IllegalEntityKind, NullPointerException
        {
                if (data == null) {
                        throw new NullPointerException("data");
                }
                if (!isKindOf(data)) {
                        throw new IllegalEntityKind(data, getClass());
                }
        }

        protected void verify(final Key key) throws NullPointerException, EntityModel.IllegalEntityKind
        {
                if (key == null) {
                        throw new NullPointerException("key");
                }
                if (isKindOf(key)) {
                        throw new IllegalEntityKind(key, getClass());
                }
        }

        @Override
        public Validation validate(final Entity data, final String successMessage)
        {
                if (data == null) {
                        throw new NullPointerException("data");
                }
                final Validation validation = Validation.withSuccessMessage(successMessage);
                doValidate(data, validation);
                return validation;
        }

        @Override
        public Validation validate(final Entity data, final Validation validation)
        {
                if (data == null) {
                        throw new NullPointerException("data");
                }
                if (validation == null) {
                        throw new NullPointerException("validation");
                }
                doValidate(data, validation);
                return validation;
        }

        protected abstract void doValidate(Entity data, Validation validation);

        protected final Query projection(final Filterable<?>... projectedProperties)
        {
                final Query q = makeQuery();
                for (final Filterable<?> filterable : projectedProperties) {
                        q.addProjection(filterable.projection());
                }
                return q;
        }

        protected final Query projection(final Iterable<Filterable<?>> projectedProperties)
        {
                final Query q = makeQuery();
                for (final Filterable<?> filterable : projectedProperties) {
                        q.addProjection(filterable.projection());
                }
                return q;
        }

        protected static final Query.Filter not(final IndexedBoolean flag)
        {
                return flag.isFalse();
        }

        protected static final Query.Filter and(final IndexedBoolean flag, final Query.Filter rhs)
        {
                return Query.CompositeFilterOperator.AND.of(flag.isTrue(), rhs);
        }

        protected static final Query.Filter or(final IndexedBoolean flag, final Query.Filter rhs)
        {
                return Query.CompositeFilterOperator.OR.of(flag.isTrue(), rhs);
        }

        protected static final Query.Filter and(final Query.Filter lhs, final IndexedBoolean flag)
        {
                return Query.CompositeFilterOperator.AND.of(flag.isTrue(), lhs);
        }

        protected static final Query.Filter or(final Query.Filter lhs, final IndexedBoolean flag)
        {
                return Query.CompositeFilterOperator.OR.of(flag.isTrue(), lhs);
        }

        protected abstract Iterable<JsonField> jsonKeyFields(Key key);
}
